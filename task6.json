{"camera":{"position":[2.3590084995710483,0.8615203713766865,10.16241461380295],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"attribute vec4 vertex_worldSpace;\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\nvarying vec3 origin;\nvarying vec3 dir;\n\nvoid main() {\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n        vertex_worldSpace.y*orthographicFOV,\n        0);\n        dir_camSpace = vec3(0, -0.15, -1);\n    }\n    else { // perspective projection\n        origin_camSpace = vec3(0);\n        dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n        vertex_worldSpace.y,\n        -1.0/tan(radians(perspectiveFOV)));\n    }\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n    gl_Position = vertex_worldSpace;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\nuniform vec3 light_source;\nvarying vec3 origin;\nvarying vec3 dir;\n\nfloat neg(float x){\n    if(x>0.001){\n        return x;\n    }else{\n        return 999.0;\n    }\n}\n\nstruct Ray{\n    vec3 ori;\n    vec3 dir;\n};\n\n\n//Sphere implememnts\nstruct Sphere{\n    vec3 centre;\n    float radius;\n    vec3 colour;\n};\n\nvec2 intersect(Ray ray, Sphere sph){\n    vec3 del_p = ray.ori-sph.centre;\n    float doting = dot(ray.dir,del_p);\n    float norming = dot(del_p,del_p);\n    float inner = doting*doting-norming+sph.radius*sph.radius;\n    if(inner<=0.0){\n        return vec2(neg(-1.0),neg(-1.0));\n    }\n    float term = sqrt(inner);\n    return vec2(neg(-doting-term),neg(-doting+term));  // near, far\n}\n\nRay reflection(Ray ray, Sphere sph, float inter){\n    Ray outray;\n    outray.ori = ray.ori+inter*ray.dir;\n    outray.dir = reflect(ray.dir,normalize(outray.ori-sph.centre));\n    outray.dir = normalize(outray.dir);\n    return outray;\n}\n\n//refraction only apply to sphere, not plane\nRay refraction(Ray ray, Sphere sph, float inter, float refrac){\n    vec3 point = ray.ori + ray.dir*inter;\n    vec3 norming = point-sph.centre; // get normal (outside)\n    float n_v = dot(ray.dir, -norming);\n    vec3 out_dir = refrac*((sqrt(n_v*n_v+1.0/refrac/refrac-1.0)-n_v)*norming+ray.dir);\n    Ray tore;\n    tore.ori = point;\n    tore.dir = normalize(out_dir);\n    return tore;\n}\n\n//Plane implements\nstruct Plane{\n    vec3 point;\n    vec3 normal;\n    vec3 colour;\n};\n\nfloat intersect(Ray ray, Plane pln){\n    return neg(-dot(ray.ori-pln.point,pln.normal)/dot(ray.dir,pln.normal));\n}\n\nRay reflection(Ray ray, Plane pln, float inter){\n    Ray outray;\n    outray.ori = ray.ori+inter*ray.dir;\n    outray.dir = reflect(ray.dir,normalize(pln.normal));\n    outray.dir = normalize(outray.dir);\n    return outray;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 random3(vec3 co){\n    return vec3(rand(co.xy),rand(co.yz),rand(co.zx));\n}\n\nvec3 find_light(vec3 point, vec3 norm, vec3 colour, Sphere[6] obstacles){\n    // check obstacle\n    float phis = 200.0;\n    float shadows = 1.0;\n    float dist = length(point - light_source);\n    for(int j=0;j<100;j++){\n        Ray checker;\n        checker.ori = point;\n        checker.dir = normalize(light_source+2.0*random3(vec3(j,j+10,j+20))-point);\n        for(int i=0;i<6;i++){\n            vec2 obs = intersect(checker, obstacles[i]);\n            float inter = obs.x;\n            if(obs.y<obs.x){\n                inter = obs.y;\n            }\n            if(inter<neg(-1.0)){\n                float shad = 0.02;\n                if(i==0 || i==5){\n                    shad = 0.015;\n                }\n                shadows -= shad*rand(vec2(j,j+10));\n            }\n        }\n    }\n    \n    float dist2 = dist*dist;\n\n    // calculate LN\n    vec3 light =  light_source-point;\n    light = normalize(light);\n    vec3 norm1 = normalize(norm);// n\n    float LN = max(dot(norm1,light),0.0);\n\n    float n = 10.0; //shinness\n\n    vec3 ray = light_source-point;\n    vec3 view = vec3(0.0,0.0,0.0);\n    ray = normalize(ray); \n    view = normalize(view-point); //v\n    vec3 r = reflect(-light, norm1);\n    float rterm = max(0.0, dot(view,r));\n\n\n    vec3 a = colour*0.5;\n    vec3 d = colour*0.1;\n    vec3 s = vec3(1.0, 1.0, 1.0);\n    vec3 I_spec = s*pow(rterm,n);\n\n\n    vec3 I_out =  a + (d*LN+s* I_spec)*phis/(4.0*3.14*dist2);\n    return shadows*I_out;\n}\n\nvec3 plane_color(vec3 pos){\n    vec3 pos1 = floor(pos*2.0);\n    pos1 = pos1-2.0*floor(pos1/2.0);\n    if(pos1.x==pos1.z){\n        return vec3(1,1,1);\n    }else{\n        return vec3(0,0,0);\n    }\n}\n\n//main program for each fragment of the render quad\nvoid main() {\n    Sphere sphere[6];\n    Plane plane;\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.3,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.8,0.8);\n    plane.point = vec3(0, -0.5, 0);\n    plane.normal = vec3(0, 1.0, 0.0);\n    plane.colour = vec3(0.6, 0.6, 0.6);\n    Ray view_ray;\n    view_ray.ori = origin;\n    view_ray.dir = normalize(dir);\n    Ray ray = view_ray;\n    vec3 accumu = vec3(0,0,0);\n    float intense = 1.0;\n    for(int j=0;j<8;j++){\n        //Scan through objects\n        float dist = neg(-1.0);\n        vec3 toadd = vec3(0,0,0);\n        Ray new_ray;\n        float inter = intersect(ray, plane);\n        if(inter<dist){\n            dist = inter;\n            new_ray = reflection(ray, plane, dist);\n            toadd = find_light(new_ray.ori, plane.normal, plane_color(new_ray.ori)*intense, sphere);\n        }\n        for(int i=0;i<6;i++){\n            vec2 inter = intersect(ray, sphere[i]);\n            if(inter.x<dist){\n                dist = inter.x;\n                if(i==0||i==5){ // transparent ball\n                    new_ray = refraction(ray, sphere[i], dist, 0.8);\n                }else{ // mirror ball\n                    new_ray = reflection(ray, sphere[i], dist);\n                }\n                toadd = find_light(new_ray.ori, normalize(new_ray.ori-sphere[i].centre), sphere[i].colour*intense, sphere);\n            }\n        }\n        accumu += toadd;\n        if(dist==neg(-1.0)){\n            break;\n        }\n        ray = new_ray;\n        intense /= 3.0;\n    }\n    gl_FragColor = vec4(accumu,1.0);\n}"}},"uniforms":{"value":{"canvasWidth":{"value":[20]},"canvasHeight":{"value":[10]},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"value":[false]},"orthographicFOV":{"value":[1]},"perspectiveFOV":{"value":[5]},"textureRendered":{"value":{"TEXTURE_2D":""}},"light_source":{"value":[-3,2,1]}}}}}},"output":{"image":"Quad/R2T Pass color"}}