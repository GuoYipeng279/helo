{"camera":{"position":[6.074274463126134,4.524351105156236,-1.247743092114961],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"cube","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWireframe":true},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\n//main program for each vertex\nvoid main() {\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  gl_Position = pMatrix * vertex_camSpace;\n\n\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\nvec3 RGB_HSV(vec3 rgb){\n    vec3 hsv = vec3(0.0,0.0,0.0);\n    hsv.z = max(rgb.x,max(rgb.y,rgb.z));\n    float rgb_min = min(rgb.x,min(rgb.y,rgb.z));\n    hsv.y = (hsv.z-rgb_min)/hsv.z;\n    if (rgb_min==rgb.z){\n        hsv.x = 120.0*(rgb.y-rgb_min)/(rgb.x+rgb.y-2.0*rgb_min);\n    }else if (rgb_min==rgb.x){\n        hsv.x = 120.0*(rgb.z-rgb_min)/(rgb.z+rgb.y-2.0*rgb_min)+120.0;\n    }else {\n        hsv.x = 120.0*(rgb.x-rgb_min)/(rgb.z+rgb.x-2.0*rgb_min)+240.0;\n    }\n    return hsv;\n}\n\nvec3 HSV_RGB(vec3 hsv){\n    vec3 rgb = vec3(0.0,0.0,0.0);\n    float max_rgb = hsv.z;\n    float min_rgb = (1.0-hsv.y)*max_rgb;\n    float H = hsv.x;\n    if (hsv.x<120.0){\n        rgb.z = min_rgb;\n        float gb_rb = 120.0/H-1.0;\n        if (gb_rb>1.0){\n        rgb.x = max_rgb;\n        rgb.y = (max_rgb-min_rgb)/gb_rb+min_rgb;\n        }else{\n        rgb.y = max_rgb;\n        rgb.x = (max_rgb-min_rgb)*gb_rb+min_rgb;\n        }\n    }else if (hsv.x<240.0){\n        rgb.x = min_rgb;\n        H -= 120.0;\n        float br_gr = 120.0/H-1.0;\n        if (br_gr>1.0){\n        rgb.y = max_rgb;\n        rgb.z = (max_rgb-min_rgb)/br_gr+min_rgb;\n        }else{\n        rgb.z = max_rgb;\n        rgb.y = (max_rgb-min_rgb)*br_gr+min_rgb;\n        }\n    }else{\n        rgb.y = min_rgb;\n        H -= 240.0;\n        float rg_bg = 120.0/H-1.0;\n        if (rg_bg>1.0){\n        rgb.z = max_rgb;\n        rgb.x = (max_rgb-min_rgb)/rg_bg+min_rgb;\n        }else{\n        rgb.x = max_rgb;\n        rgb.z = (max_rgb-min_rgb)*rg_bg+min_rgb;\n        }\n    }\n    return rgb;\n}\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  vec3 rgb = vec3(1.0,0.5,1.0);\n  vec3 rgb1 = HSV_RGB(RGB_HSV(rgb));\n  gl_FragColor = vec4(rgb1, 1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}