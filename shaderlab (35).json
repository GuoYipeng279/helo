{"camera":{"position":[-3.6931399838376247,19.604731473646382,17.051766973132043],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\n//main program for each vertex\nvoid main() {\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  gl_Position = pMatrix * vertex_camSpace;\n\n\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"attribute vec4 vertex_worldSpace;\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\nvarying vec3 origin;\nvarying vec3 dir;\nvoid main() {\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n        vertex_worldSpace.y*orthographicFOV,\n        0);\n        dir_camSpace = vec3(0, -0.15, -1);\n    }\n    else { // perspective projection\n        origin_camSpace = vec3(0);\n        dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n        vertex_worldSpace.y,\n        -1.0/tan(radians(perspectiveFOV)));\n    }\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n    gl_Position = vertex_worldSpace;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\nuniform vec3 light_source;\nvarying vec3 origin;\nvarying vec3 dir;\n\nfloat neg(float x){\n    if(x>0.001){\n        return x;\n    }else{\n        return 999.0;\n    }\n}\n\nstruct Ray{\n    vec3 ori;\n    vec3 dir;\n};\n\n\n//Sphere implememnts\nstruct Sphere{\n    vec3 centre;\n    float radius;\n    vec3 colour;\n};\n\nvec2 intersect(Ray ray, Sphere sph){\n    vec3 del_p = ray.ori-sph.centre;\n    float doting = dot(ray.dir,del_p);\n    float norming = dot(del_p,del_p);\n    float inner = doting*doting-norming+sph.radius*sph.radius;\n    if(inner<=0.0){\n        return vec2(neg(-1.0),neg(-1.0));\n    }\n    float term = sqrt(inner);\n    return vec2(neg(-doting-term),neg(-doting+term));  // near, far\n}\n\nRay reflection(Ray ray, Sphere sph, float inter){\n    Ray outray;\n    outray.ori = ray.ori+inter*ray.dir;\n    outray.dir = reflect(ray.dir,normalize(outray.ori-sph.centre));\n    outray.dir = normalize(outray.dir);\n    return outray;\n}\n\n\n//Plane implements\nstruct Plane{\n    vec3 point;\n    vec3 normal;\n    vec3 colour;\n};\n\nfloat intersect(Ray ray, Plane pln){\n    return neg(-dot(ray.ori-pln.point,pln.normal)/dot(ray.dir,pln.normal));\n}\n\nRay reflection(Ray ray, Plane pln, float inter){\n    Ray outray;\n    outray.ori = ray.ori+inter*ray.dir;\n    outray.dir = reflect(ray.dir,normalize(pln.normal));\n    outray.dir = normalize(outray.dir);\n    return outray;\n}\n\nvec3 find_light(vec3 point, vec3 norm, vec3 colour, Sphere[6] obstacles){\n    // check obstacle\n    float phis = 200.0;\n    float dist = length(point - light_source);\n    Ray checker;\n    checker.ori = point;\n    checker.dir = normalize(light_source-point);\n    for(int i=0;i<6;i++){\n        float inter = intersect(checker, obstacles[i]).x;\n        if(inter<neg(-1.0)){\n            phis = 0.0;\n            break;\n        }\n    }\n    \n    float dist2 = dist*dist;\n\n    // calculate LN\n    vec3 light =  light_source-point;\n    light = normalize(light);\n    vec3 norm1 = normalize(norm);// n\n    float LN = max(dot(norm1,light),0.0);\n\n    float n = 10.0; //shinness\n\n    vec3 ray = light_source-point;\n    vec3 view = vec3(0.0,0.0,0.0);\n    ray = normalize(ray); \n    view = normalize(view-point); //v\n    vec3 r = reflect(-light, norm1);\n    float rterm = max(0.0, dot(view,r));\n\n\n    vec3 a = colour*0.5;\n    vec3 d = colour*0.1;\n    vec3 s = vec3(1.0, 1.0, 1.0);\n    vec3 I_spec = s*pow(rterm,n);\n\n\n    vec3 I_out =  a + (d*LN+s* I_spec)*phis/(4.0*3.14*dist2);\n    return I_out;\n}\n\nvec3 plane_color(vec3 pos){\n    vec3 pos1 = floor(pos*2.0);\n    pos1 = pos1-2.0*floor(pos1/2.0);\n    if(pos1.x==pos1.z){\n        return vec3(1,1,1);\n    }else{\n        return vec3(0,0,0);\n    }\n}\n\n//main program for each fragment of the render quad\nvoid main() {\n    Sphere sphere[6];\n    Plane plane;\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n    plane.point = vec3(0, -0.5, 0);\n    plane.normal = vec3(0, 1.0, 0.0);\n    plane.colour = vec3(0.6, 0.6, 0.6);\n    Ray view_ray;\n    view_ray.ori = origin;\n    view_ray.dir = normalize(dir);\n    Ray ray = view_ray;\n    vec3 accumu = vec3(0,0,0);\n    float intense = 1.0;\n    for(int j=0;j<8;j++){\n        //Scan through objects\n        float dist = neg(-1.0);\n        vec3 toadd = vec3(0,0,0);\n        Ray new_ray;\n        float inter = intersect(ray, plane);\n        if(inter<dist){\n            dist = inter;\n            new_ray = reflection(ray, plane, dist);\n            toadd = find_light(new_ray.ori, plane.normal, plane_color(new_ray.ori)*intense, sphere);\n        }\n        for(int i=0;i<6;i++){\n            vec2 inter = intersect(ray, sphere[i]);\n            if(inter.x<dist){\n                dist = inter.x;\n                new_ray = reflection(ray, sphere[i], dist);\n                toadd = find_light(new_ray.ori, normalize(new_ray.ori-sphere[i].centre), sphere[i].colour*intense, sphere);\n            }\n        }\n        accumu += toadd;\n        if(dist==neg(-1.0)){\n            break;\n        }\n        ray = new_ray;\n        intense /= 3.0;\n    }\n    gl_FragColor = vec4(accumu,1.0);\n}"}},"uniforms":{"value":{"canvasWidth":{"value":[20]},"canvasHeight":{"value":[10]},"cameraPosition":{"value":[0,1,4]},"cameraRotation":{"value":[1,0,0,0,1,0,0,0,1]},"isOrthographicProjection":{"value":[true]},"orthographicFOV":{"value":[1]},"perspectiveFOV":{"value":[5]},"textureRendered":{"attachment":"Model/base Pass color"},"light_source":{"value":[-3,1,1]}}}}}},"output":{"image":"Quad/R2T Pass color"}}