{"camera":{"position":[10.018510617210758,1.1145608674854308,-38.709006692057166],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWireframe":false},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\nvarying vec4 I_out;\n\nvarying float LN;\n\n//main program for each vertex\nvoid main() {\n    vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n    gl_Position = pMatrix * vertex_camSpace;\n    vec3 light_source = vec3(0.0,0.0,0.0);\n\n    float phis = 5000.0;\n\n    float dist2 = pow(length(vertex_camSpace.xyz - light_source),2.0);\n\n    // calculate LN\n    vec3 light =  light_source-vertex_camSpace.xyz ; // is from the object to the light source, always (all the vectors are from the object pointing outwards)\n    vec4 norm4 = vMatrix*mMatrix*vec4(normal_worldSpace,0.0); // why minus?\n    vec3 norm = norm4.xyz;\n    light = normalize(light);\n    norm = normalize(norm);// n\n    LN = max(dot(norm,light),0.0); // you need to use max prevent < 0 values \n\n    float n = 10.0; //shinness\n\n    vec3 ray = light_source-vertex_camSpace.xyz ; // is from the object to the light source, always (all the vectors are from the object pointing outwards)\n    vec3 view = vec3(0.0,0.0,0.0); // your camera is always at 0 0 0 in camera space instead of 0 0 1\n    ray = normalize(ray); \n    view = normalize(view-vertex_camSpace.xyz); //v\n    vec3 r = reflect(-light, norm);\n    float rterm = max(0.0, dot(view,r));\n\n\n    vec4 a = vec4(0.5, 0.0, 0.0, 1.0);\n    vec4 d = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 s = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 I_spec = s*pow(rterm,n);\n    \n\n    I_out =  a + (d*LN+s* I_spec)*5000.0/(4.0*3.14*dist2); \n\n\n\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\nvarying vec4 I_out;\n\nvarying float LN;\n\n//main program for each fragment = pixel candidate\nvoid main() {\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    vec4 I;\n    if(LN>0.98){\n        I = vec4(0.8,0.8,0.8,1.0);\n    }else if(LN>0.5){\n        I = vec4(0.8,0.4,0.4,1.0);\n    }else if(LN>0.25){\n        I = vec4(0.6,0.2,0.2,1.0);\n    }else{\n        I = vec4(0.1,0.1,0.1,1.0);\n    }\n\n    gl_FragColor = I_out;\n    //gl_FragColor = I;\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}